如果编写的功能的正确性需要第三者来验证，为了能最大程度上的节约寻找问题的时间和保证代码经过反复更改之后的正确性，测试的重要性在这种场景之下非常高。

单元测试只测试函数的功能，不依赖数据库、网络，单元测试保证是在函数粒度下输入正确的情况下输出正确。

单元测试应该先从完全不依赖编写功能中任何其他函数(这些函数本身也需要测试)的函数开始，在此称为这些函数为原子函数: 不依赖任何其他需要测试函数的函数。

在保证原子函数正确性之后，测试就应该过渡到仅仅只依赖原子函数的函数，我们称这些函数为分子函数：分子函数是仅仅只依赖原子函数的函数。

在保证分子函数正确性之后，测试过渡到需要依赖外部环境的函数，比如数据库、网络等，这些函数或实例的方法调用最终将会把计算的数据以各种各样的方式输出到外部软件，比如数据库、缓存、磁盘或者一次 http 请求。在此我们称这样的函数为实体函数：与外界进行交互的函数。这样的测试我们称之为集成测试。

任何测试都离不开输入和输出，为了能够保证测试的顺利和快速执行以及代码的迅速变更和重构，测试要具有足够的灵活性。有几个原则可以先确立下来执行过程中慢慢改进。

如果测试输入样例少于 3 个，这三个样例完全可以手动编写完成
如果输入样例多余 5 个以上，需要编写测试程序来保证输入在任何时候都是一致的。
对于需要依赖时间的测试，一定要模拟清楚测试边界的条件和范围，事先可以通过手动描述出不同的边界和范围。

利用 nose 的特性为不同的测试函数打上不同的标签，把原子函数测试，分子函数和实体函数分开，按修改之后的影响程度进行测试。

```
nosetests -a tag=b test_package
```

## 测试用例编写

### 分层

测试用例按照原子函数、分子函数、实体函数进行分层，测试顺序

1. 原子函数
2. 分子函数
3. 实体函数

回归测试：修改 1，测试 1，2，3；修改 2，测试 2，3；修改 3 测试 3

## 测试条件编写

所有的逻辑都可以用分支和循环来表示，为了编写满足覆盖所有分支的测试条件，几个原则

1. 优先测试范围（0~0.5, 0.5~1, 1~1.5,....），重点测试边界(0, 0.5, 1, 1.5, ...)
2. 借用分支和循环，排列组合所有测试条件
3. 手动计算每个范围和每个边界的正确输出，一个就可以，要确保足够正确


## 可测性

为了让测试案例编写容易，测试准确，函数要具备为很好的可测性，衡量可测性的标准


- 函数职责单一
- 单一的输入，必然产生单一的输出，不具有二义性